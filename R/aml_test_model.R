#' Function to test the model and conditionally decide to update existing model for a single currency pair
#'
#' @description Function is designed to test the trading decision generated by the Deep learning regression model.
#' The outcome of this function will be used to perform update of existing model with a fresh data.
#'
#' @details  Function is reading shifted price data and corresponding indicator.
#' Starting from the trained model function will test the trading strategy using simplified trading approach.
#' Trading approach will entail using the last available indicator data, predict the price change for every row,
#' shift predicted value by 34 bars as we will hold the asset for 34 bars.
#' Account for the real price change after 34 bars by creating a cumulative sum column
#' Verify obtained summary results on the model and obtain virtual real/simulated result
#' is consolidated to calculate model quality. Whenever this value is less than 0
#' function is writing dedicated decision using simple *.csv file
#' Such file will be used by the function aml_make_model.R to decide whether model must be updated...
#'
#' @author (C) 2020 Vladimir Zhbanko
#'
#' @param symbol              Character symbol of the asset for which to train the model
#' @param timeframe           Data timeframe e.g. 60 min
#' @param path_model          Path where the models are be stored
#' @param path_data           Path where the aggregated historical data is stored, if exists in rds format
#'
#' @return Function is writing file into Decision Support System folder
#' @export
#'
#' @examples
#'
#' \donttest{
#'
#' library(dplyr)
#' library(magrittr)
#' library(readr)
#' library(h2o)
#' library(lazytrade)
#' library(lubridate)
#'
#' path_model <- normalizePath(tempdir(),winslash = "/")
#' path_data <- normalizePath(tempdir(),winslash = "/")
#'
#' ind = system.file("extdata", "AI_RSIADXUSDJPY60.csv",
#'                   package = "lazytrade") %>% read_csv(col_names = F)
#'
#' ind$X1 <- ymd_hms(ind$X1)
#'
#' write_csv(ind, file.path(path_data, "AI_RSIADXUSDJPY60.csv"), col_names = FALSE)
#'
#' # data transformation using the custom function for one symbol
#' aml_collect_data(indicator_dataset = ind,
#'                  symbol = 'USDJPY',
#'                  timeframe = 60,
#'                  path_data = path_data)
#'
#'
#' # start h2o engine (using all CPU's by default)
#' h2o.init()
#'
#'
#' # performing Deep Learning Regression using the custom function
#' aml_make_model(symbol = 'USDJPY',
#'                timeframe = 60,
#'                path_model = path_model,
#'                path_data = path_data,
#'                force_update=FALSE)
#'
#' path_sbxm <- normalizePath(tempdir(),winslash = "/")
#' path_sbxs <- normalizePath(tempdir(),winslash = "/")
#'
#' # score the latest data to generate predictions for one currency pair
#' aml_score_data(symbol = 'USDJPY',
#'                timeframe = 60,
#'                path_model = path_model,
#'                path_data = path_data,
#'                path_sbxm = path_sbxm,
#'                path_sbxs = path_sbxs)
#'
#' # test the results of predictions
#' aml_test_model(symbol = 'USDJPY',
#'                timeframe = 60,
#'                path_model = path_model,
#'                path_data = path_data)
#'
#' # stop h2o engine
#' h2o.shutdown(prompt = FALSE)
#'
#' #set delay to insure h2o unit closes properly before the next test
#' Sys.sleep(5)
#'
#' }
#'
#'
#'
aml_test_model <- function(symbol, timeframe, path_model, path_data){

  requireNamespace("dplyr", quietly = TRUE)
  requireNamespace("readr", quietly = TRUE)
  requireNamespace("h2o", quietly = TRUE)

  #construct the path to the data object see function aml_collect_data.R
  # generate a file name to be able to read the right dataset
  f_name <- paste0("AI_RSIADX", symbol,timeframe, ".rds")
  full_path <- file.path(path_data,  f_name)


  ## !!!!!! TDL
  ## only select the latest 30% of data... or only last 2 month


  #dataset with date column X1
  y <- readr::read_rds(full_path) %>%
    # remove empty rows
    na.omit() %>% filter_all(any_vars(. != 0))


  #dataset without X1 column (for predictions)
  x <- y  %>%
    select(-X1, -X2, -X3, -LABEL) %>%
    # only keep last month for simulation
    head(600)

  # generate a file name for model
  m_name <- paste0("DL_Regression", "-", symbol,"-", timeframe)
  m_path <- file.path(path_model, m_name)
  #load model
  ModelR <- h2o::h2o.loadModel(path = m_path)

  # uploading data to h2o
  recent_ML  <- h2o::as.h2o(x = x, destination_frame = "recent_ML")
  # PREDICT the next period...
  result_R <- h2o::h2o.predict(ModelR, recent_ML) %>% as.data.frame()

  ## Checking the trading strategy assuming we open and hold position for 3, 5, 10, 34 bars!

  # To DO: Add ATR multiplier to simulate TP/SL
  # add for loop for ATR Multiplier

  # Note: Position will only be opened if predicted price is higher than a Trigger
  Trigger <- c(10, 20, 30, 40, 50, 60, 70)
  # trying different levels
  for (TR in Trigger) {
    #TR <- 10


  dat31 <- y %>%
    # using last 600 observations
    head(600) %>%
    ## select columns:
    # X1 time index
    # X2 price at the time index
    # X3 price 34 bars ago
    # LABEL is a price difference X3-X2
    dplyr::select(X1, X2) %>%
    # add column with predicted price change
    dplyr::bind_cols(result_R) %>%
    ## create columns:
    # dP_34 - price difference now vs 34 bars (only for check)
    # dplyr::mutate(dP_34 = X3-X2) %>%
    ## setup condition to enter the trade
    # create a risk column, use 20 pips as a trigger
    dplyr::mutate(Risk = if_else(predict > TR, 1, if_else(predict < -TR, -1, 0))) %>%
    ## create several columns with shifted X2 price down:
    # X2_3, X2_5, X2_10 where 3, 5, 10 indicates number of bars we will hold this position
    dplyr::mutate(X2_3 = lag(X2, 3),
                  X2_5 = lag(X2, 5),
                  X2_10 = lag(X2, 10),
                  X2_34 = lag(X2, 34)) %>%
    # clean up this dataset
    na.omit() %>%
    # now calculate several scenarios:
    dplyr::mutate(Hold_3 = Risk*(X2_3 - X2),
                  Hold_5 = Risk*(X2_5 - X2),
                  Hold_10 = Risk*(X2_10 - X2),
                  Hold_34 = Risk*(X2_34 - X2)) %>%


    # remove zero values to calculate presumed number of trades
    dplyr::filter(Risk != 0) %>%
    # get the sum of columns
    # Column Expected PNL would be the result in case all trades would be successful
    # Column Achieved PNL is the results achieved in reality
    dplyr::summarise(PnL_3 = sum(Hold_3),
                     PnL_5 = sum(Hold_5),
                     PnL_10 = sum(Hold_10),
                     PnL_34 = sum(Hold_34),
                     TotalTrades = n(),
                     TPSL_Level = TR) %>%

  # interpret the results
  dplyr::mutate(AchievedPnL = sum(PnL_3, PnL_5, PnL_10, PnL_34),
                FinalOutcome = if_else(AchievedPnL > 0, "VeryGood", "VeryBad"))

  # record results of testing
  if(!exists("df_res")){
    df_res <- dat31
  } else {
    df_res <- df_res %>% dplyr::bind_rows(dat31)
  }




  } #end of the for loop

  ## select the best trading option (Trigger and Max Hours option)
  # select amount of bars to hold the position and suggested Trigger


  df_tr <- df_res %>%
    select(1:4, 6) %>%
    tidyr::pivot_longer(!TPSL_Level) %>%
    arrange(desc(value)) %>%
    head(1)




  ## write condition to the csv file
  dec_file_name <- paste0("StrTest-", symbol, "M",timeframe, ".csv")
  dec_file_path <- file.path(path_model,  dec_file_name)
  readr::write_csv(df_tr, dec_file_path)

  #h2o.shutdown(prompt = FALSE)




}


